### 1. Display Table of 10

```java
public class TableOfTen {
    public static void main(String[] args) {
        int num = 10;
        for (int i = 1; i <= 10; i++) {
            System.out.println(num + " x " + i + " = " + (num * i));
        }
    }
}
```

### 2. Display Fibonacci Series of 10 Numbers

```java
public class FibonacciSeries {
    public static void main(String[] args) {
        int n = 10, firstTerm = 0, secondTerm = 1;
        System.out.println("Fibonacci Series till " + n + " terms:");

        for (int i = 1; i <= n; ++i) {
            System.out.print(firstTerm + ", ");
            int nextTerm = firstTerm + secondTerm;
            firstTerm = secondTerm;
            secondTerm = nextTerm;
        }
    }
}
```

### 3. Check Whether a Given Number is Odd or Even

```java
import java.util.Scanner;

public class OddOrEven {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        System.out.print("Enter a number: ");
        int num = scanner.nextInt();

        if (num % 2 == 0) {
            System.out.println(num + " is even.");
        } else {
            System.out.println(num + " is odd.");
        }
    }
}
```

### 4. Find Largest of Two Numbers

```java
import ");
        int num1 = scanner.nextInt();
        System.out.print("Enter second number: ");
        int num2 = scanner.nextInt();

        if (num1 > num2) {
            System.out.println(num1 + " is larger.");
        } else if (num2 > num1) {
            System.out.println(num2 + " is larger.");
        } else {
            System.out.println("Both numbers are equal.");
        }
    }
}
```

### 5. Create an Array of Numbers and Display the Original Array in Sorted Order

```java
import java.util.Arrays;

public class SortArray {
    public static void main(String[] args) {
        int[] numbers = {5, 3, 8, 1, 2};
        Arrays.sort(numbers);
        System.out.println("Sorted array: " + Arrays.toString(numbers));
    }
}
```

### 6. Create an Array of Numbers and Display the Original Array in Reverse Order

```java
import java.util.Arrays;

public class ReverseArray {
    public static void main(String[] args) {
        int[] numbers = {5, 3, 8, 1, 2};
        System.out.println("Original array: " + Arrays.toString(numbers));
        
        System.out.print("Reversed array: ");
        for (int i = numbers.length - 1; i >= 0; i--) {
            System.out.print(numbers[i] + " ");
        }
    }
}
```



### 1. **Classes and Objects**
- **Class**: A blueprint for creating objects. It defines a datatype by bundling data and methods that work on the data.
- **Object**: An instance of a class. It is created using the `new` keyword.

```java
// Class definition
class Car {
    String color;
    String model;

    // Method
    void display() {
        System.out.println("Model: " + model + ", Color: " + color);
    }
}

// Creating an object
public class Main {
    public static void main(String[] args) {
        Car myCar = new Car();
        myCar.color = "Red";
        myCar.model = "Tesla Model S";
        myCar.display();  // Output: Model: Tesla Model S, Color: Red
    }
}
```

### 2. **Inheritance**
Inheritance allows a new class to inherit properties and methods from an existing class.

```java
// Base class
class Animal {
    void eat() {
        System.out.println("This animal eats food.");
    }
}

// Derived class
class Dog extends Animal {
    void bark() {
        System.out.println("The dog barks.");
    }
}

public class Main {
    public static void main(String[] args) {
        Dog myDog = new Dog();
        myDog.eat();  // Inherited method
        myDog.bark(); // Specific method
    }
}
```

### 3. **Polymorphism**
Polymorphism allows methods to do different things based on the object it is acting upon.

```java
class Animal {
    void sound() {
        System.out.println("This animal makes a sound.");
    }
}

class Cat extends Animal {
    void sound() {
        System.out.println("The cat meows.");
    }
}

class Dog extends Animal {
    void sound() {
        System.out.println("The dog barks.");
    }
}

public class Main {
    public static void main(String[] args) {
        Animal myAnimal = new Animal();
        Animal myCat = new Cat();
        Animal myDog = new Dog();

        myAnimal.sound();  // Output: This animal makes a sound.
        myCat.sound();     // Output: The cat meows.
        myDog.sound();     // Output: The dog barks.
    }
}
```

### 4. **Encapsulation**
Encapsulation is the technique of making the fields in a class private and providing access via public methods.

```java
class Person {
    private String name;

    // Getter method
    public String getName() {
        return name;
    }

    // Setter method
    public void setName(String name) {
        this.name = name;
    }
}

public class Main {
    public static void main(String[] args) {
        Person person = new Person();
        person.setName("Alice");
        System.out.println(person.getName());  // Output: Alice
    }
}
```

### 5. **Abstraction**
Abstraction is the concept of hiding the complex implementation details and showing only the necessary features.

```java
abstract class Animal {
    abstract void makeSound();

    void sleep() {
        System.out.println("This animal is sleeping.");
    }
}

class Dog extends Animal {
    void makeSound() {
        System.out.println("The dog barks.");
    }
}

public class Main {
    public static void main(String[] args) {
        Dog myDog = new Dog();
        myDog.makeSound();  // Output: The dog barks.
        myDog.sleep();      // Output: This animal is sleeping.
    }
}
```

